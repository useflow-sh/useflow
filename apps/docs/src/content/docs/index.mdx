---
title: useFlow
description: Type-safe, declarative multi-step flows for React applications with built-in persistence
template: splash
hero:
  tagline: Easiest way to build complex app flows.
  actions:
    - text: Get Started
      link: /getting-started/overview
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/useflow-sh/useflow
      icon: external
      variant: minimal
---

import { Card, CardGrid, Steps, Code, Tabs, TabItem, LinkCard } from "@astrojs/starlight/components";

## Build multi-step flows without the complexity

<CardGrid stagger>
  <Card title="Declarative" icon="document">
    Centralized, declarative flow structure. No more conditional navigation
    logic scattered across components.
  </Card>
  <Card title="Built-in Persistence" icon="seti:db">
    Enable with 2 lines of code. Users continue exactly where they left off.
  </Card>
  <Card title="Type-Safe" icon="seti:typescript">
    Full TypeScript support. Your IDE knows every step, catches navigation errors at compile time.
  </Card>
  <Card title="Lightweight" icon="rocket">
    Under 5KB gzipped. Zero dependencies. Just React.
  </Card>
</CardGrid>

## See it in action

Build a complete onboarding flow in 3 simple steps:

<Steps>

1. ### Define your flow with branching

   ```tsx
   import { defineFlow } from "@useflow/react";

   type OnboardingContext = {
     email?: string;
     accountType?: "business" | "personal";
     company?: string;
   };

   const onboardingFlow = defineFlow({
     id: "onboarding",
     start: "welcome",
     steps: {
       welcome: { next: "userType" },
       userType: { next: ["business", "personal"] }, // Branching!
       business: { next: "complete" },
       personal: { next: "complete" },
       complete: {}
     }
   }).with<OnboardingContext>((steps) => ({
     resolvers: {
       // Type-safe: can only return steps in next array
       userType: (ctx) => 
         ctx.accountType === "business" 
           ? steps.business  // ‚úÖ Valid
           : steps.personal  // ‚úÖ Valid
       // steps.complete would be ‚ùå TypeScript error
     }
   }));
   ```

2. ### Create your step components

   ```tsx
   import { useFlow } from "@useflow/react";

   function UserTypeStep() {
     const { context, setContext, next } = useFlow();
     
     const handleSubmit = () => {
       next(); // Automatically navigates based on accountType
     };

     return (
       <div>
         <h1>Get Started</h1>
         <input
           type="email"
           placeholder="Email address"
           value={context.email || ""}
           onChange={(e) => setContext({ email: e.target.value })}
         />
         <select 
           value={context.accountType || ""}
           onChange={(e) => setContext({ accountType: e.target.value })}
         >
           <option value="">Choose account type</option>
           <option value="personal">Personal</option>
           <option value="business">Business</option>
         </select>
         <button 
           onClick={handleSubmit}
           disabled={!context.email || !context.accountType}
         >
           Continue
         </button>
       </div>
     );
   }

   function BusinessStep() {
     const { context, setContext, next, back } = useFlow();
     
     return (
       <div>
         <h1>Business Details</h1>
         <p>Welcome {context.email}!</p>
         <input
           placeholder="Company name"
           value={context.company || ""}
           onChange={(e) => setContext({ company: e.target.value })}
         />
         <button onClick={back}>Back</button>
         <button onClick={next}>Continue</button>
       </div>
     );
   }
   ```

3. ### Add persistence with 2 lines

   ```tsx
   import { Flow, createLocalStorageStore, createPersister } from "@useflow/react";

   const persister = createPersister({ 
     store: createLocalStorageStore() 
   });

    <Flow flow={onboardingFlow} persister={persister}>
      {({ renderStep }) => renderStep({
        // TypeScript enforces all steps must be provided - can't miss any!
        welcome: <WelcomeStep />,
        userType: <UserTypeStep />,
        business: <BusinessStep />,
        personal: <PersonalStep />,
        complete: <CompleteStep />
      })}
    </Flow>
   ```

</Steps>

**That's it!** Users can now close their browser and return exactly where they left off. No manual state management, no localStorage code, no navigation logic.

## Perfect for

- üöÄ **Onboarding flows** - User registration with multiple steps
- üõí **Checkout processes** - Cart, shipping, payment, confirmation  
- üìù **Surveys & forms** - Long questionnaires users can resume
- ‚öôÔ∏è **Configuration wizards** - Complex setup broken into steps
- üìã **Application processes** - Job applications, loan applications

## Why not just use...?

<Tabs>
  <TabItem label="useState">
    ```tsx
    // Week 1: "This is simple!"
    const [step, setStep] = useState('welcome');
    const [formData, setFormData] = useState({});
    
    // Week 2: "We need persistence"
    const [step, setStep] = useState(() => 
      localStorage.getItem('onboarding-step') || 'welcome'
    );
    const [formData, setFormData] = useState(() => 
      JSON.parse(localStorage.getItem('onboarding-data') || '{}')
    );
    
    useEffect(() => {
      localStorage.setItem('onboarding-step', step);
      localStorage.setItem('onboarding-data', JSON.stringify(formData));
    }, [step, formData]);
    
    // Week 3: "We need branching logic"
    const handleNext = () => {
      if (step === 'welcome') setStep('profile');
      else if (step === 'profile') {
        if (formData.accountType === 'business') {
          setStep('companyInfo');
        } else {
          setStep('preferences');
        }
      }
      else if (step === 'companyInfo') setStep('preferences');
      else if (step === 'preferences') setStep('complete');
    };
    
    // Week 4: "We need back button"
    const [stepHistory, setStepHistory] = useState(['welcome']);
    const handleBack = () => {
      const newHistory = stepHistory.slice(0, -1);
      setStepHistory(newHistory);
      setStep(newHistory[newHistory.length - 1]);
    };
    
    // Week 5: "We need analytics"
    const handleNext = () => {
      const nextStep = getNextStep(step, formData);
      analytics.track('step_completed', { 
        from: step, 
        to: nextStep,
        ...formData 
      });
      setStepHistory([...stepHistory, nextStep]);
      setStep(nextStep);
    };
    
    // Week 6: "Product wants to add email verification"
    // Now updating logic in 5 different places...
    // 300+ lines of tangled state management
    ```
    **Reality:** What starts as 3 lines becomes 300+ lines of fragile, interconnected logic.
  </TabItem>
  <TabItem label="React Router">
    Each step as a route sounds good until:
    - No shared state without Context/Redux
    - No built-in persistence
    - Browser back button breaks flow logic
    - Still building all navigation logic yourself
    
    **Better for:** Page navigation, not multi-step processes.
  </TabItem>
  <TabItem label="Form Libraries">
    React Hook Form, Formik, etc. are great for forms, but:
    - Don't handle step navigation
    - No progress persistence
    - No flow branching logic
    
    **Best approach:** Use them *with* useFlow for validation.
  </TabItem>
  <TabItem label="XState">
    General state machine library:
    - Steep learning curve (actors, events, guards)
    - No built-in persistence
    - Designed for complex state logic
    - Not purpose-built for multi-step UI flows
    
    **Better for:** Complex state machines with parallel states and intricate business logic.
  </TabItem>
</Tabs>

**useFlow gives you everything out of the box:** navigation, persistence, branching, TypeScript safety, and it's under 5KB.

## Coming soon

<CardGrid>
  <Card title="Remote Configuration" icon="setting">
    Modify flows without deploying. Update step order and branching logic from your backend.
  </Card>
  <Card title="A/B Testing" icon="random">
    Test flow variants. See which path converts best.
  </Card>
  <Card title="Built-in Analytics" icon="seti:default">
    Track completion rates and drop-offs. Own your analytics.
  </Card>
</CardGrid>

## Get started

<CardGrid>
  <LinkCard
    title="Quick Start"
    description="Build your first flow. Ship a working flow in minutes"
    href="/getting-started/quick-start"
  />
  <LinkCard
    title="Why useFlow?"
    description="Learn more about benefits and comparisons"
    href="/getting-started/why-useflow"
  />
  <LinkCard
    title="Examples"
    description="Browse recipes with production-ready patterns"
    href="/recipes/onboarding"
  />
  <LinkCard
    title="API Reference"
    description="View the complete API reference docs"
    href="/api-reference/define-flow"
  />
</CardGrid>
