---
title: TypeScript
description: Leverage useFlow's powerful type safety features
---

import { Aside, Badge, FileTree, LinkCard, CardGrid } from '@astrojs/starlight/components';

# TypeScript <Badge text="Full Support" variant="tip" />

useFlow provides exceptional type safety that catches errors at compile time. No more runtime navigation errors or missing step components.

## The magic: everything is type-safe

### 1. renderStep enforces all components

TypeScript **requires** you to provide components for every step:

```tsx
const myFlow = defineFlow({
  id: "checkout",
  start: "cart",
  steps: {
    cart: { next: "shipping" },
    shipping: { next: "payment" },
    payment: { next: "confirm" },
    confirm: {}
  }
});

// In your component
<Flow flow={myFlow}>
  {({ renderStep }) => renderStep({
    cart: <CartStep />,
    shipping: <ShippingStep />,
    // ❌ TypeScript Error: Missing properties 'payment', 'confirm'
  })}
</Flow>

// ✅ Must provide ALL steps
{({ renderStep }) => renderStep({
  cart: <CartStep />,
  shipping: <ShippingStep />,
  payment: <PaymentStep />,
  confirm: <ConfirmStep />
})}
```

<Aside type="tip">
  **Why this matters:** You can never accidentally forget to implement a step. Adding a new step to your flow? TypeScript immediately tells you where to add the component.
</Aside>

### 2. Navigation is contextually aware

Each step knows **exactly** where it can navigate:

```tsx
const myFlow = defineFlow({
  id: "survey",
  start: "intro",
  steps: {
    intro: { next: "question1" },
    question1: { next: ["question2", "results"] },  // Can go to 2 places
    question2: { next: "results" },
    results: {}
  }
});

function Question1() {
  // Use the flow-specific hook with step parameter
  const { next } = myFlow.useFlow({ step: "question1" });
  
  // TypeScript knows question1 can ONLY go to these steps
  next("question2");  // ✅ Valid
  next("results");    // ✅ Valid
  next("intro");      // ❌ Error: Argument not assignable to '"question2" | "results"'
  next("invalid");    // ❌ Error: Not a valid next step
}

function Question2() {
  const { next } = myFlow.useFlow({ step: "question2" });
  
  // Different step, different valid navigation
  next("results");    // ✅ Valid (only option)
  next("question1");  // ❌ Error: Can't go back using next
}
```

<Aside type="tip">
  **Why this matters:** No more runtime errors from navigating to invalid steps. Refactoring is safe - change your flow structure and TypeScript shows you exactly what needs updating.
</Aside>

### 3. Context is fully typed

Your flow's shared data is type-safe everywhere:

```tsx
type CheckoutContext = {
  items: CartItem[];
  shippingAddress?: Address;
  paymentMethod?: PaymentMethod;
  total: number;
};

function ShippingStep() {
  const { context, setContext } = useFlow<CheckoutContext>();
  
  // TypeScript knows exactly what's in context
  console.log(context.total);           // ✅ number
  console.log(context.items.length);    // ✅ Property exists
  console.log(context.shippingAddress); // ✅ Address | undefined
  
  // Type-safe updates
  setContext({ total: 99.99 });         // ✅ Valid
  setContext({ total: "99.99" });       // ❌ Error: Type 'string' not assignable to 'number'
  setContext({ invalid: true });        // ❌ Error: 'invalid' doesn't exist
}
```

## Setting up TypeScript

### Basic flow with type inference

```tsx
import { defineFlow } from "@useflow/react";

// 1. Define your context type
type OnboardingContext = {
  email: string;
  name: string;
  preferences?: {
    theme: "light" | "dark";
    notifications: boolean;
  };
};

// 2. Create your flow (types are inferred!)
export const onboardingFlow = defineFlow({
  id: "onboarding",
  start: "email",
  steps: {
    email: { next: "profile" },
    profile: { next: "preferences" },
    preferences: { next: "complete" },
    complete: {}
  }
});

// 3. Use in components with full type safety
function ProfileStep() {
  const { context, setContext, next } = useFlow<OnboardingContext>();
  
  return (
    <div>
      <input
        value={context.name}
        onChange={(e) => setContext({ name: e.target.value })}
      />
      <button onClick={() => next()}>Continue</button>
    </div>
  );
}
```

### Branching with type safety

```tsx
type UserFlow = {
  userType?: "business" | "personal";
  businessName?: string;
  personalName?: string;
};

const branchingFlow = defineFlow({
  id: "user-flow",
  start: "choose",
  steps: {
    choose: { next: ["business", "personal"] },
    business: { next: "verify" },
    personal: { next: "verify" },
    verify: { next: "complete" },
    complete: {}
  }
}).with<UserFlow>((steps) => ({
  resolvers: {
    choose: (ctx) =>
      ctx.userType === "business" ? steps.business : steps.personal
  }
}));
```

## Best practices

### 1. Define context types upfront

```tsx
// ✅ Good: Clear, reusable type
type MyFlowContext = {
  step1Data: string;
  step2Data?: number;
};

const flow = defineFlow({...});

// Use the type consistently
function Component() {
  const { context } = useFlow<MyFlowContext>();
}
```

### 2. Use the flow's custom hook for navigation

```tsx
// ✅ Best: Step-specific type safety
function MyStep() {
  const { next } = myFlow.useFlow({ step: "currentStep" });
  // TypeScript knows valid next steps for THIS specific step
}

// ✅ OK: General usage (less type safety)
function MyStep() {
  const { next } = useFlow();
  // No step-specific navigation validation
}
```

### 3. Make optional fields explicit

```tsx
type Context = {
  // Required from start
  email: string;
  
  // Added in later steps
  name?: string;
  age?: number;
};

// Initial context only needs required fields
<Flow 
  flow={myFlow}
  initialContext={{ email: "" }} // ✅ Valid, optional fields can be omitted
/>
```

## Common patterns

### Discriminated unions for branching

```tsx
type CheckoutContext = 
  | { type: "guest"; email: string }
  | { type: "member"; userId: string; savedCards: Card[] };

function PaymentStep() {
  const { context } = useFlow<CheckoutContext>();
  
  if (context.type === "guest") {
    // TypeScript knows: context.email exists, context.userId doesn't
    return <GuestCheckout email={context.email} />;
  } else {
    // TypeScript knows: context.userId and savedCards exist
    return <MemberCheckout cards={context.savedCards} />;
  }
}
```

### Const assertions for stricter types

```tsx
// Use 'as const' for literal types
const STEPS = {
  WELCOME: "welcome",
  PROFILE: "profile", 
  COMPLETE: "complete"
} as const;

type StepName = typeof STEPS[keyof typeof STEPS];
// StepName = "welcome" | "profile" | "complete"
```

## Troubleshooting

### "Cannot navigate to step X"

<Aside type="caution">
  You're trying to navigate to a step that's not in the `next` array:
</Aside>

```tsx
// Flow definition
profile: { next: "preferences" }

// Error in component
next("welcome"); // ❌ Can't go backward with next()

// Solution: Use back() or add to next array
back(); // ✅ Goes to previous step
```

### "Missing properties in renderStep"

You haven't provided components for all steps:

```tsx
// Check your flow definition for ALL steps
const flow = defineFlow({
  steps: {
    a: { next: "b" },
    b: { next: "c" },
    c: {}  // Don't forget terminal steps!
  }
});

// Must provide all three
renderStep({
  a: <A />,
  b: <B />,
  c: <C />  // Including terminal step
});
```

## Next steps

<CardGrid>
  <LinkCard
    title="Core Concepts"
    description="Deep dive into flows and navigation"
    href="/core-concepts/"
  />
  <LinkCard
    title="Branching Guide"
    description="Build complex conditional flows"
    href="/guides/branching"
  />
  <LinkCard
    title="API Reference"
    description="Complete type definitions"
    href="/api-reference/define-flow"
  />
</CardGrid>